# Turbocharger

## > WORK IN PROGRESS <

Automatically transforms Rust async backend functions into JavaScript async frontend functions.

Or: A seamless, autogenerated, fully-typed, async RPC layer that connects a JavaScript web frontend to a Rust backend web server.

`#[turbocharger::backend]` makes a Rust async backend function, e.g.:

```rust
#[turbocharger::backend]
async fn get_greeting() -> String {
 // ... write any async backend code here; ...
 // ... query a remote database, API, etc. ...
 String::new("Hello from backend")
}
```

instantly available to your frontend as

- an async JavaScript function
- with full TypeScript type definitions
- that calls the backend over the network

```js
// export function get_greeting(): Promise<string>;

let person = await backend.get_greeting();
```

## How It Works

- auto-generates a frontend WASM module with `wasm-pack` / `wasm-bindgen`
- creates a WebSocket connection between the WASM module and the backend server
- serializes function parameters and return values with `serde` and `bincode`
- handles multiplexing and dispatch

Parameters and return values of any types that are compatible with `wasm-bindgen` should work, which includes `struct`s with compatible fields but [not yet](https://github.com/rustwasm/wasm-bindgen/pull/2631) `enum` variants with values, which would be typed as TypeScript discriminated unions.

## Complete Example: A full SQLite-powered backend with frontend bindings

Full backend and frontend project in `example-sqlite/`; run with `cargo run example-sqlite`

### `main.rs`

```rust
use serde::{Serialize, Deserialize};
use turbocharger::{backend, server_only};
use turbosql::{Turbosql, select};

#[derive(Turbosql, Serialize, Deserialize, Default)]
struct Person {
 rowid: Option<i64>,
 name: Option<String>
}

#[backend]
async fn get_person(rowid: i64) -> Result<Person, anyhow::Error> {
 turbosql::select!(Person "WHERE rowid = ?", rowid)
}

#[server_only]
#[tokio::main]
async fn main() {
 Person { name: "Demo Person", ..Default::default() }.insert().unwrap();
 eprintln!("Serving on http://127.0.0.1:8080");
 warp::serve(turbocharger::warp_routes()).run(([127, 0, 0, 1], 8080)).await;
}
```

### `index.js`

```js
import turbocharger_init, { backend } from "./turbocharger_generated";

(async () => {
 await turbocharger_init();
 console.log(await backend.get_person(1n));
})();
```

## Usage

Your `main.rs` file is the entry point for both the server `bin` target and a `wasm-bindgen` `lib` target. The `#[backend]` macro outputs three functions:

- Your function, unchanged, for the server `bin` target; you can call it directly from other server code if you wish.
- An internal function for the server `bin` target providing the RPC glue.
- A `#[wasm_bindgen]` function for the frontend WASM module that makes the RPC call and shepherds the response.

## Server

Currently, the server side of Turbocharger is batteries-included based on `tokio` and `warp`, but this could be decoupled in the future.

## To Do / Future Directions

- Better WebSocket status management / reconnect
- Error handling with `Result::Err` triggering a Promise rejection
- Streaming responses with `futures::stream`
- `Vec<T>` types, see [wasm-bindgen#111](https://github.com/rustwasm/wasm-bindgen/issues/111)
- Anything [`tarpc`](https://github.com/google/tarpc) does, particularly around timeouts, cancellation, etc.

### License: MIT OR Apache-2.0 OR CC0-1.0 (public domain)
